From 8296db068336040ee5887e3870635e5b3f6553ea Mon Sep 17 00:00:00 2001
From: Jeremiah Orians <jeremiah@pdp10.guru>
Date: Thu, 6 Aug 2020 21:17:53 -0400
Subject: [PATCH 10/17] Revert to more minimal kaem for core bootstrap More
 advanced version is available on kaem branch

---
 Kaem/.gitignore               |  12 -
 Kaem/README                   |   6 -
 Kaem/kaem.c                   | 893 ----------------------------------
 Kaem/kaem.h                   |  81 ---
 Kaem/kaem.run                 |  59 ---
 Kaem/makefile                 |  57 ---
 Kaem/test.sh                  |  25 -
 Kaem/test/.gitignore          |   1 -
 Kaem/test/test.answers        |  16 -
 Kaem/test/test00/kaem.test    |  18 -
 Kaem/test/test01/kaem.test    |  19 -
 Kaem/test/test02/kaem.test    |  18 -
 Kaem/test/test03/kaem.test    |  19 -
 Kaem/test/test04/kaem.test    |  20 -
 Kaem/test/test05/kaem.test    |  19 -
 Kaem/test/test06/kaem.test    |  20 -
 Kaem/test/test07/kaem.test    |  18 -
 Kaem/test/test08/kaem.test    |  18 -
 Kaem/test/test09/kaem.test    |  18 -
 Kaem/test/test10/kaem.test    |  21 -
 Kaem/test/test10/subkaem.test |  18 -
 Kaem/test/test11/kaem.test    |  19 -
 Kaem/test/test12/kaem.test    |  18 -
 Kaem/test/test13/kaem.test    |  18 -
 Kaem/test/test14/kaem.test    |  19 -
 Kaem/test/test15/kaem.test    |   6 -
 Kaem/variable.c               | 284 -----------
 kaem.c                        | 705 +++++++++++++++++++++++++++
 makefile                      |   5 +-
 test.sh                       |   1 -
 30 files changed, 707 insertions(+), 1744 deletions(-)
 delete mode 100644 Kaem/.gitignore
 delete mode 100644 Kaem/README
 delete mode 100644 Kaem/kaem.c
 delete mode 100644 Kaem/kaem.h
 delete mode 100755 Kaem/kaem.run
 delete mode 100644 Kaem/makefile
 delete mode 100755 Kaem/test.sh
 delete mode 100644 Kaem/test/.gitignore
 delete mode 100644 Kaem/test/test.answers
 delete mode 100644 Kaem/test/test00/kaem.test
 delete mode 100644 Kaem/test/test01/kaem.test
 delete mode 100644 Kaem/test/test02/kaem.test
 delete mode 100644 Kaem/test/test03/kaem.test
 delete mode 100644 Kaem/test/test04/kaem.test
 delete mode 100644 Kaem/test/test05/kaem.test
 delete mode 100644 Kaem/test/test06/kaem.test
 delete mode 100644 Kaem/test/test07/kaem.test
 delete mode 100644 Kaem/test/test08/kaem.test
 delete mode 100644 Kaem/test/test09/kaem.test
 delete mode 100644 Kaem/test/test10/kaem.test
 delete mode 100644 Kaem/test/test10/subkaem.test
 delete mode 100644 Kaem/test/test11/kaem.test
 delete mode 100644 Kaem/test/test12/kaem.test
 delete mode 100644 Kaem/test/test13/kaem.test
 delete mode 100644 Kaem/test/test14/kaem.test
 delete mode 100644 Kaem/test/test15/kaem.test
 delete mode 100644 Kaem/variable.c
 create mode 100644 kaem.c

diff --git a/Kaem/.gitignore b/Kaem/.gitignore
deleted file mode 100644
index df5988f..0000000
--- a/Kaem/.gitignore
+++ /dev/null
@@ -1,12 +0,0 @@
-# Ignore build directory
-bin/
-
-# Ignore Temp directory
-temp/
-
-# Ignore test result directory
-test/results/
-
-# Ignore temp and special files
-*.tst
-*.qst
diff --git a/Kaem/README b/Kaem/README
deleted file mode 100644
index 84cdd8d..0000000
--- a/Kaem/README
+++ /dev/null
@@ -1,6 +0,0 @@
-kaem is the world's worst build tool.
-You really really should use make instead.
-
-This tool exists only as the bare bottom floor scriptable build tool for bootstrapping.
-
-Avoid as there be dragons here.
diff --git a/Kaem/kaem.c b/Kaem/kaem.c
deleted file mode 100644
index d1ecf7e..0000000
--- a/Kaem/kaem.c
+++ /dev/null
@@ -1,893 +0,0 @@
-/* Copyright (C) 2016-2020 Jeremiah Orians
- * Copyright (C) 2020 fosslinux
- * This file is part of mescc-tools.
- *
- * mescc-tools is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * mescc-tools is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include <sys/wait.h>
-#include "kaem.h"
-
-/* Prototypes from other files */
-void handle_variables(char** argv, struct Token* n);
-
-/*
- * UTILITY FUNCTIONS
- */
-
-/* Function to find a character in a string */
-char* find_char(char* string, char a)
-{
-	if(0 == string[0]) return NULL;
-	while(a != string[0])
-	{
-		string = string + 1;
-		if(0 == string[0]) return string;
-	}
-	return string;
-}
-
-/* Function to find the length of a char**; an array of strings */
-int array_length(char** array)
-{
-	int length = 0;
-	while(array[length] != NULL)
-	{
-		length = length + 1;
-	}
-	return length;
-}
-
-/* Search for a variable in the env linked-list */
-char* env_lookup(char* variable)
-{
-	/* Start at the head */
-	struct Token* n = env;
-	/* Loop over the linked-list */
-	while(n != NULL)
-	{
-		if(match(variable, n->var))
-		{ /* We have found the correct node */
-			return n->value; /* Done */
-		}
-		/* Nope, try the next */
-		n = n->next;
-	}
-	/* We didn't find anything! */
-	return NULL;
-}
-
-/* Find the full path to an executable */
-char* find_executable(char* name)
-{
-	if(match("", name)) return NULL;
-	if(('.' == name[0]) || ('/' == name[0]))
-	{ /* assume names that start with . or / are relative or absolute */
-		return name;
-	}
-
-	char* trial = calloc(MAX_STRING, sizeof(char));
-	char* MPATH = calloc(MAX_STRING, sizeof(char)); /* Modified PATH */
-	require(MPATH != NULL, "Memory initialization of MPATH in find_executable failed\n");
-	copy_string(MPATH, PATH);
-	FILE* t;
-	char* next = find_char(MPATH, ':');
-	int index;
-	int offset;
-	int mpath_length;
-	int name_length;
-	int trial_length;
-	while(NULL != next)
-	{
-		/* Reset trial */
-		trial_length = string_length(trial);
-		for(index = 0; index < trial_length; index = index + 1)
-		{
-			trial[index] = 0;
-		}
-
-		next[0] = 0;
-
-		/* prepend_string(MPATH, prepend_string("/", name)) */
-		mpath_length = string_length(MPATH);
-		for(index = 0; index < mpath_length; index = index + 1)
-		{
-			require(MAX_STRING > index, "Element of PATH is too long\n");
-			trial[index] = MPATH[index];
-		}
-		trial[index] = '/';
-		offset = string_length(trial);
-		name_length = string_length(name);
-		for(index = 0; index < name_length; index = index + 1)
-		{
-			require(MAX_STRING > index, "Element of PATH is too long\n");
-			trial[index + offset] = name[index];
-		}
-
-		/* Try the trial */
-		require(string_length(trial) < MAX_STRING, "COMMAND TOO LONG!\nABORTING HARD\n");
-		t = fopen(trial, "r");
-		if(NULL != t)
-		{
-			fclose(t);
-			return trial;
-		}
-
-		MPATH = next + 1;
-		next = find_char(MPATH, ':');
-	}
-	return NULL;
-}
-
-/* Function to convert a Token linked-list into an array of strings */
-char** list_to_array(struct Token* s)
-{
-	struct Token* n;
-	n = s;
-	char** array = calloc(MAX_ARRAY, sizeof(char*));
-	require(array != NULL, "Memory initialization of array in conversion of list to array failed\n");
-	char* element = calloc(MAX_STRING, sizeof(char));
-	require(element != NULL, "Memory initialization of element in conversion of list to array failed\n");
-	int index = 0;
-	int i;
-	int value_length;
-	int var_length;
-	int offset;
-	while(n != NULL)
-	{ /* Loop through each node and assign it to an array index */
-		array[index] = calloc(MAX_STRING, sizeof(char));
-		require(array[index] != NULL, "Memory initialization of array[index] in conversion of list to array failed\n");
-		/* Bounds checking */
-		/* No easy way to tell which it is, output generic message */
-		require(index < MAX_ARRAY, "SCRIPT TOO LONG or TOO MANY ENVARS\nABORTING HARD\n");
-		if(n->var == NULL)
-		{ /* It is a line */
-			array[index] = n->value;
-		}
-		else
-		{ /* It is a var */
-			/* prepend_string(n->var, prepend_string("=", n->value)) */
-			var_length = string_length(n->var);
-			for(i = 0; i < var_length; i = i + 1)
-			{
-				element[i] = n->var[i];
-			}
-			element[i] = '=';
-			i = i + 1;
-			offset = i;
-			value_length = string_length(n->value);
-			for(i = 0; i < value_length; i = i + 1)
-			{
-				element[i + offset] = n->value[i];
-			}
-		}
-		copy_string(array[index], element);
-
-		n = n->next;
-		index = index + 1;
-
-		/* Reset element */
-		for(i = 0; i < MAX_STRING; i = i + 1) element[i] = 0;
-	}
-	return array;
-}
-
-/*
- * TOKEN COLLECTION FUNCTIONS
- */
-
-/* Function for skipping over line comments */
-void collect_comment(FILE* input)
-{
-	int c;
-	/* Eat up the comment, one character at a time */
-	/*
-	 * Sanity check that the comment ends with \n.
-	 * Remove the comment from the FILE*
-	 */
-	do
-	{
-		c = fgetc(input);
-		/* We reached an EOF!! */
-		require(EOF != c, "IMPROPERLY TERMINATED LINE COMMENT!\nABORTING HARD\n");
-	} while('\n' != c); /* We can now be sure it ended with \n -- and have purged the comment */
-}
-
-/* Function for collecting strings and removing the "" pair that goes with them */
-int collect_string(FILE* input, struct Token* n, int index)
-{
-	int string_done = FALSE;
-	int c;
-	do
-	{
-		/* Bounds check */
-		require(MAX_STRING > index, "LINE IS TOO LONG\nABORTING HARD\n");
-		c = fgetc(input);
-		require(EOF != c, "IMPROPERLY TERMINATED STRING!\nABORTING HARD\n");
-
-		if('"' == c)
-		{ /* End of string */
-			string_done = TRUE;
-		}
-		else
-		{
-			require(MAX_STRING > index, "LINE IS TOO LONG\nABORTING HARD\n");
-			n->value[index] = c;
-			index = index + 1;
-		}
-	} while(string_done == FALSE);
-	return index;
-}
-
-/* Function to parse and assign token->value */
-int collect_token(FILE* input, struct Token* n, int last_index)
-{
-	int c;
-	int token_done = FALSE;
-	char* token = calloc(MAX_STRING, sizeof(char));
-	require(token != NULL, "Memory initialization of token in collect_token failed\n");
-	int index = 0;
-	do
-	{ /* Loop over each character in the token */
-		c = fgetc(input);
-		/* Bounds checking */
-		require(MAX_STRING > index, "LINE IS TOO LONG\nABORTING HARD\n");
-		if(EOF == c)
-		{ /* End of file -- this means script complete */
-			/* We don't actually exit here. This logically makes more sense;
-			 * let the code follow its natural path of execution and exit
-			 * sucessfuly at the end of main().
-			 */
-			token_done = TRUE;
-			command_done = TRUE;
-			return -1;
-		}
-		else if((' ' == c) || ('\t' == c))
-		{ /* Space and tab are token seperators */
-			token_done = TRUE;
-		}
-		else if('\n' == c)
-		{ /* Command terminates at end of a line */
-			command_done = TRUE;
-			token_done = TRUE;
-			if(0 == index) index = last_index;
-		}
-		else if('"' == c)
-		{ /* Handle strings -- everything between a pair of "" */
-			index = collect_string(input, n, index);
-			token_done = TRUE;
-		}
-		else if('#' == c)
-		{ /* Handle line comments */
-			collect_comment(input);
-			command_done = TRUE;
-			token_done = TRUE;
-			if(0 == index) index = last_index;
-		}
-		else if('\\' == c)
-		{ /* Support for escapes; drops the char after */
-			/******************************************************************
-			 * This is a design decision; it is primarily made for newlines.  *
-			 * Unlike the way normal shells do escapes (making the next char  *
-			 * actually do something), this just eats it up. Why? Simply, to  *
-			 * aid formatting (mostly through newlines). Eventually, we will  *
-			 * make it do it the proper way... but for now it's staying like  *
-			 * this. Feel free to send in a patch if you have a solution!     *
-			 * Because of this, I have decided that since the behaviour is    *
-			 * signficant enough, when warnings are enabled, we will give a   *
-			 * warning about this.                                            *
-			 ******************************************************************/
-			c = fgetc(input); /* Skips over \, gets the next char */
-			if(WARNINGS && c != '\n')
-			{
-				file_print("WARNING: The character '", stdout);
-				fputc(c, stdout);
-				file_print("' just got eaten up because of an unsupported escape sequence; see kaem.c:collect_token for more information.\n", stdout);
-			}
-			index = index + 2;
-		}
-		else if(0 == c)
-		{ /* We have come to the end of the token */
-			token_done = TRUE;
-		}
-		else
-		{ /* It's a character to assign */
-			require(MAX_STRING > index, "LINE IS TOO LONG\nABORTING HARD\n");
-			n->value[index] = c;
-			index = index + 1;
-		}
-	} while (token_done == FALSE);
-	return index;
-}
-
-/*
- * EXECUTION FUNCTIONS
- * Note: All of the builtins return FALSE (0) when they exit successfully
- * and TRUE (1) when they fail.
- */
-
-/* Function to check if the token is an envar */
-int is_envar(char* token)
-{
-	int i = 0;
-	int token_length = string_length(token);
-	while(i < token_length)
-	{
-		if(token[i] == '=')
-		{
-			return TRUE;
-		}
-		i = i + 1;
-	}
-	return FALSE;
-}
-
-/* Add an envar */
-int add_envar()
-{
-	/* If we are in init-mode and this is the first var env == NULL, rectify */
-	if(env == NULL)
-	{
-		env = calloc(1, sizeof(struct Token));
-		require(env != NULL, "Memory initialization of env failed\n");
-	}
-
-	struct Token* n;
-	n = env;
-	/* Traverse to end of linked-list */
-	while(n->next != NULL)
-	{
-		if(n->next->value == NULL || n->next->var == NULL) break;
-		n = n->next;
-	}
-	/* Initialize new node */
-	/* See first comment, this situation means no new node */
-	if(n->value != NULL || n->var != NULL || n->next != NULL)
-	{
-		n->next = calloc(1, sizeof(struct Token));
-		require(n->next != NULL, "Memory initialization of next env node in add_envar failed\n");
-		n = n->next;
-	}
-
-	/*
-	 * If you are confused about n->* and token->value here:
-	 * token->value: is the token with the raw data. Part of token linked list.
-	 * n->*: is where it goes. Part of env linked list.
-	 */
-	/* Get n->var */
-	int index = 0;
-	n->var = calloc(MAX_STRING, sizeof(char));
-	require(n->var != NULL, "Memory initialization of n->var in add_envar failed\n");
-	int token_length = string_length(token->value);
-	/* Copy into n->var up to = */
-	while(token->value[index] != '=')
-	{
-		if(index >= token_length) return TRUE;
-		n->var[index] = token->value[index];
-		index = index + 1;
-	}
-
-	/* Get n->value */
-	index = index + 1; /* Skip over = */
-	int offset = index;
-	n->value = calloc(MAX_STRING, sizeof(char));
-	require(n->value != NULL, "Memory initialization of n->value in add_envar failed\n");
-	/* Copy into n->value up to end of token */
-	while(token->value[index] != 0)
-	{
-		if(index >= token_length) return TRUE;
-		n->value[index - offset] = token->value[index];
-		index = index + 1;
-	}
-	return FALSE;
-}
-
-/* cd builtin */
-int cd()
-{
-	if(NULL == token->next) return TRUE;
-	token = token->next;
-	if(NULL == token->value) return TRUE;
-	int ret = chdir(token->value);
-	if(0 > ret) return TRUE;
-	return FALSE;
-}
-
-/* pwd builtin */
-int pwd()
-{
-	char* path = calloc(MAX_STRING, sizeof(char));
-	require(path != NULL, "Memory initialization of path in pwd failed\n");
-	getcwd(path, MAX_STRING);
-	require(!match("", path), "getcwd() failed\n");
-	file_print(path, stdout);
-	file_print("\n", stdout);
-	return FALSE;
-}
-
-/* set builtin */
-int set()
-{
-	/* Get the options */
-	int i;
-	if(NULL == token->next) goto cleanup_set;
-	token = token->next;
-	if(NULL == token->value) goto cleanup_set;
-	char* options = calloc(MAX_STRING, sizeof(char));
-	require(options != NULL, "Memory initialization of options in set failed\n");
-
-	int last_position = string_length(token->value) - 1;
-	for(i = 0; i < last_position; i = i + 1)
-	{
-		options[i] = token->value[i + 1];
-	}
-	/* Parse the options */
-	int options_length = string_length(options);
-	for(i = 0; i < options_length; i = i + 1)
-	{
-		if(options[i] == 'a')
-		{ /* set -a is on by default and cannot be disabled at this time */
-			if(WARNINGS)
-			{
-				file_print("set -a is on by default and cannot be disabled\n", stdout);
-			}
-			continue;
-		}
-		else if(options[i] == 'e')
-		{ /* Fail on failure */
-			STRICT = TRUE;
-		}
-		else if(options[i] == 'x')
-		{ /* Show commands as executed */
-			/* TODO: this currently behaves like -v. Make it do what it should */
-			VERBOSE = TRUE;
-			/*
-			 * Output the set -x because VERBOSE didn't catch it before.
-			 * We don't do just -x because we support multiple options in one command,
-			 * eg set -ex.
-			 */
-			file_print(" +> set -", stdout);
-			file_print(options, stdout);
-			file_print("\n", stdout);
-			fflush(stdout);
-		}
-		else
-		{ /* Invalid */
-			fputc(options[i], stderr);
-			file_print(" is an invalid set option!\n", stderr);
-			exit(EXIT_FAILURE);
-		}
-	}
-	return FALSE;
-cleanup_set:
-	return TRUE;
-}
-
-/* echo builtin */
-void echo()
-{
-	if(token->next == NULL)
-	{ /* No arguments */
-		file_print("\n", stdout);
-		return;
-	}
-	if(token->next->value == NULL)
-	{ /* No arguments */
-		file_print("\n", stdout);
-		return;
-	}
-	token = token->next; /* Skip the actual echo */
-	while(token != NULL)
-	{ /* Output each argument to echo to stdout */
-		/* M2-Planet doesn't let us do this in the while */
-		if(token->value == NULL) break;
-		file_print(token->value, stdout);
-		file_print(" ", stdout);
-		token = token->next;
-	}
-	file_print("\n", stdout);
-}
-
-/* unset builtin */
-void unset()
-{
-	struct Token* e;
-	/* We support multiple variables on the same line */
-	struct Token* t;
-	t = token->next;
-	while(t != NULL)
-	{
-		e = env;
-		/* Look for the variable; we operate on ->next because we need to remove ->next */
-		while(e->next != NULL)
-		{
-			if(match(e->next->var, t->value))
-			{
-				break;
-			}
-			e = e->next;
-		}
-		t = t->next;
-		/* If it's NULL nothing was found */
-		if(e->next == NULL) continue;
-		/* Otherwise there is something to unset */
-		e->next = e->next->next;
-	}
-}
-
-/* Execute program */
-int execute()
-{ /* Run the command */
-
-	/* rc = return code */
-	int rc;
-
-	/* Actually do the execution */
-	if(is_envar(token->value) == TRUE)
-	{
-		rc = add_envar();
-		if(STRICT) require(rc == FALSE, "Adding of an envar failed!\n");
-		return 0;
-	}
-	else if(match(token->value, "cd"))
-	{
-		rc = cd();
-		if(STRICT) require(rc == FALSE, "cd failed!\n");
-		return 0;
-	}
-	else if(match(token->value, "set"))
-	{
-		rc = set();
-		if(STRICT) require(rc == FALSE, "set failed!\n");
-		return 0;
-	}
-	else if(match(token->value, "pwd"))
-	{
-		rc = pwd();
-		if(STRICT) require(rc == FALSE, "pwd failed!\n");
-		return 0;
-	}
-	else if(match(token->value, "echo"))
-	{
-		echo();
-		return 0;
-	}
-	else if(match(token->value, "unset"))
-	{
-		unset();
-		return 0;
-	}
-
-	/* If it is not a builtin, run it as an executable */
-	int status; /* i.e. return code */
-	char** array;
-	char** envp;
-	/* Get the full path to the executable */
-	char* program = find_executable(token->value);
-	/* Check we can find the executable */
-	if(NULL == program)
-	{
-		if(STRICT == TRUE)
-		{
-			file_print("WHILE EXECUTING ", stderr);
-			file_print(token->value, stderr);
-			file_print(" NOT FOUND!\nABORTING HARD\n", stderr);
-			exit(EXIT_FAILURE);
-		}
-		/* If we are not strict simply return */
-		return 0;
-	}
-
-	int f = fork();
-	/* Ensure fork succeeded */
-	if (f == -1)
-	{
-		file_print("WHILE EXECUTING ", stderr);
-		file_print(token->value, stderr);
-		file_print("fork() FAILED\nABORTING HARD\n", stderr);
-		exit(EXIT_FAILURE);
-	}
-	else if (f == 0)
-	{ /* Child */
-		/**************************************************************
-		 * Fuzzing produces random stuff; we don't want it running    *
-		 * dangerous commands. So we just don't execve.               *
-		 * But, we still do the list_to_array calls to check for      *
-		 * segfaults.                                                 *
-		 **************************************************************/
-		array = list_to_array(token);
-		envp = list_to_array(env);
-
-		if(FALSE == FUZZING)
-		{ /* We are not fuzzing */
-			/* execve() returns only on error */
-			execve(program, array, envp);
-		}
-		/* Prevent infinite loops */
-		_exit(EXIT_SUCCESS);
-	}
-
-	/* Otherwise we are the parent */
-	/* And we should wait for it to complete */
-	waitpid(f, &status, 0);
-
-	return status;
-}
-
-int collect_command(FILE* script, char** argv)
-{
-	command_done = FALSE;
-	/* Initialize token */
-	token = calloc(1, sizeof(struct Token));
-	require(token != NULL, "Memory initialization of token in collect_command failed\n");
-	struct Token* n;
-	n = token;
-	int index = 0;
-	/* Get the tokens */
-	while(command_done == FALSE)
-	{
-		n->value = calloc(MAX_STRING, sizeof(char));
-		index = collect_token(script, n, index);
-		/* Don't allocate another node if the current one yielded nothing, OR
-		 * if we are done.
-		 */
-		if((n->value != NULL && match(n->value, "") == FALSE) && command_done == FALSE)
-		{
-			n->next = calloc(MAX_STRING, sizeof(char));
-			require(token != NULL, "Memory initialization of next token node in collect_command failed\n");
-			n = n->next;
-		}
-	}
-	/* -1 means the script is done */
-	if(EOF == index) return index;
-
-	n = token;
-	while(n != NULL)
-	{ /* Substitute variables into each token */
-		if(n->value == NULL) break;
-		handle_variables(argv, n);
-		/* Advance to next node */
-		n = n->next;
-	}
-
-	/* Output the command if verbose is set */
-	/* Also if there is nothing in the command skip over */
-	if(VERBOSE && match(token->value, "") == FALSE)
-	{
-		n = token;
-		file_print(" +> ", stdout);
-		while(n != NULL)
-		{ /* Print out each token token */
-			/* M2-Planet doesn't let us do this in the while */
-			if(n->value == NULL) break;
-			file_print(n->value, stdout);
-			file_print(" ", stdout);
-			n = n->next;
-		}
-		fputc('\n', stdout);
-		fflush(stdout);
-	}
-	return index;
-}
-
-/* Function for executing our programs with desired arguments */
-void run_script(FILE* script, char** argv)
-{
-	while(TRUE)
-	{
-		/*
-		 * Tokens has to be reset each time, as we need a new linked-list for
-		 * each line.
-		 * See, the program flows like this as a high level overview:
-		 * Get line -> Sanitize line and perform variable replacement etc ->
-		 * Execute line -> Next.
-		 * We don't need the previous lines once they are done with, so tokens
-		 * are hence for each line.
-		 */
-		int index = collect_command(script, argv);
-		/* -1 means the script is done */
-		if(EOF == index) break;
-		if(0 == index) continue;
-
-		/* Stuff to exec */
-		int status = execute();
-		if(STRICT == TRUE && (0 != status))
-		{ /* Clearly the script hit an issue that should never have happened */
-			file_print("Subprocess error ", stderr);
-			file_print(numerate_number(status), stderr);
-			file_print("\nABORTING HARD\n", stderr);
-			exit(EXIT_FAILURE);
-		}
-	}
-}
-
-/* Function to populate env */
-void populate_env(char** envp)
-{
-	/* Initialize env and n */
-	env = calloc(1, sizeof(struct Token));
-	require(env != NULL, "Memory initialization of env failed\n");
-	struct Token* n;
-	n = env;
-
-	int i;
-	for(i = 0; i < array_length(envp); i = i + 1)
-	{
-		n->var = calloc(MAX_STRING, sizeof(char));
-		require(n->var != NULL, "Memory initialization of n->var in population of env failed\n");
-		n->value = calloc(MAX_STRING, sizeof(char));
-		require(n->value != NULL, "Memory initialization of n->var in population of env failed\n");
-		int j = 0;
-		/*
-		 * envp is weird.
-		 * When referencing envp[i]'s characters directly, they were all jumbled.
-		 * So just copy envp[i] to envp_line, and work with that - that seems
-		 * to fix it.
-		 */
-		char* envp_line = calloc(MAX_STRING, sizeof(char));
-		require(envp_line != NULL, "Memory initialization of envp_line in population of env failed\n");
-		copy_string(envp_line, envp[i]);
-		while(envp_line[j] != '=')
-		{ /* Copy over everything up to = to var */
-			n->var[j] = envp_line[j];
-			j = j + 1;
-		}
-		/* If we get strange input, we need to ignore it */
-		if(n->var == NULL) continue;
-		j = j + 1; /* Skip over = */
-		int k = 0; /* As envp[i] will continue as j but n->value begins at 0 */
-		while(envp_line[j] != 0)
-		{ /* Copy everything else to value */
-			n->value[k] = envp_line[j];
-			j = j + 1;
-			k = k + 1;
-		}
-		/* Sometimes, we get lines like VAR=, indicating nothing is in the variable */
-		if(n->value == NULL) n->value = "";
-		/* Advance to next part of linked list */
-		n->next = calloc(1, sizeof(struct Token));
-		require(n->next != NULL, "Memory initialization of n->next in population of env failed\n");
-		n = n->next;
-	}
-	/* Get rid of node on the end */
-	n = NULL;
-	/* Also destroy the n->next reference */
-	n = env;
-	while(n->next->var != NULL) n = n->next;
-	n->next = NULL;
-}
-
-int main(int argc, char** argv, char** envp)
-{
-	VERBOSE = FALSE;
-	STRICT = FALSE;
-	FUZZING = FALSE;
-	WARNINGS = FALSE;
-	char* filename = "kaem.run";
-	FILE* script = NULL;
-
-	/* Initalize structs */
-	token = calloc(1, sizeof(struct Token));
-	require(token != NULL, "Memory initialization of token failed\n");
-
-	int i = 1;
-	/* Loop over arguments */
-	while(i <= argc)
-	{
-		if(NULL == argv[i])
-		{ /* Ignore the argument */
-			i = i + 1;
-		}
-		else if(match(argv[i], "-h") || match(argv[i], "--help"))
-		{ /* Help information */
-			file_print("Usage: ", stdout);
-			file_print(argv[0], stdout);
-			file_print(" [-h | --help] [-V | --version] [--file filename | -f filename] [-i | --init-mode] [-v | --verbose] [--strict] [--warn] [--fuzz]\n", stdout);
-			exit(EXIT_SUCCESS);
-		}
-		else if(match(argv[i], "-f") || match(argv[i], "--file"))
-		{ /* Set the filename */
-			if(argv[i + 1] != NULL)
-			{
-				filename = argv[i + 1];
-			}
-			i = i + 2;
-		}
-		else if(match(argv[i], "-i") || match(argv[i], "--init-mode"))
-		{ /* init mode does not populate env */
-			INIT_MODE = TRUE;
-			i = i + 1;
-		}
-		else if(match(argv[i], "-V") || match(argv[i], "--version"))
-		{ /* Output version */
-			file_print("kaem version 1.0.0\n", stdout);
-			exit(EXIT_SUCCESS);
-		}
-		else if(match(argv[i], "-v") || match(argv[i], "--verbose"))
-		{ /* Set verbose */
-			VERBOSE = TRUE;
-			i = i + 1;
-		}
-		else if(match(argv[i], "--strict"))
-		{ /* Set strict */
-			STRICT = TRUE;
-			i = i + 1;
-		}
-		else if(match(argv[i], "--warn"))
-		{ /* Set warnings */
-			WARNINGS = TRUE;
-			i = i + 1;
-		}
-		else if(match(argv[i], "--fuzz"))
-		{ /* Set fuzzing */
-			FUZZING = TRUE;
-			i = i + 1;
-		}
-		else if(match(argv[i], "--"))
-		{ /* Nothing more after this */
-			break;
-		}
-		else
-		{ /* We don't know this argument */
-			file_print("UNKNOWN ARGUMENT\n", stdout);
-			exit(EXIT_FAILURE);
-		}
-	}
-
-	/* Populate env */
-	if(INIT_MODE == FALSE)
-	{
-		populate_env(envp);
-	}
-
-	/* Populate PATH variable
-	 * We don't need to calloc() because env_lookup() does this for us.
-	 */
-	PATH = env_lookup("PATH");
-
-	/* Populate USERNAME variable */
-	char* USERNAME = env_lookup("LOGNAME");
-
-	/* Handle edge cases */
-	if((NULL == PATH) && (NULL == USERNAME))
-	{ /* We didn't find either of PATH or USERNAME -- use a generic PATH */
-		PATH = calloc(MAX_STRING, sizeof(char));
-		require(PATH != NULL, "Memory initialization of PATH failed\n");
-		copy_string(PATH, "/root/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin");
-	}
-	else if(NULL == PATH)
-	{ /* We did find a username but not a PATH -- use a generic PATH but with /home/USERNAME */
-		PATH = prepend_string("/home/", prepend_string(USERNAME,"/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games"));
-	}
-
-	/* Open the script */
-	script = fopen(filename, "r");
-	if(NULL == script)
-	{
-		file_print("The file: ", stderr);
-		file_print(filename, stderr);
-		file_print(" can not be opened!\n", stderr);
-		exit(EXIT_FAILURE);
-	}
-
-	/* Run the commands */
-	run_script(script, argv);
-
-	/* Cleanup */
-	fclose(script);
-	return EXIT_SUCCESS;
-}
diff --git a/Kaem/kaem.h b/Kaem/kaem.h
deleted file mode 100644
index ff2b4bd..0000000
--- a/Kaem/kaem.h
+++ /dev/null
@@ -1,81 +0,0 @@
-/* Copyright (C) 2016-2020 Jeremiah Orians
- * Copyright (C) 2020 fosslinux
- * This file is part of mescc-tools.
- *
- * mescc-tools is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * mescc-tools is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdio.h>
-
-/*
- * DEFINES
- */
-
-#define FALSE 0
-//CONSTANT FALSE 0
-#define TRUE 1
-//CONSTANT TRUE 1
-#define MAX_STRING 4096
-//CONSTANT MAX_STRING 4096
-#define MAX_ARRAY 256
-//CONSTANT MAX_ARRAY 256
-
-/* Imported */
-int match(char* a, char* b);
-void file_print(char* s, FILE* f);
-void require(int bool, char* error);
-char* copy_string(char* target, char* source);
-char* prepend_string(char* add, char* base);
-int string_length(char* a);
-char* numerate_number(int a);
-
-/*
- * GLOBALS
- */
-
-int command_done;
-int VERBOSE;
-int STRICT;
-int INIT_MODE;
-int FUZZING;
-int WARNINGS;
-char* PATH;
-
-/*
- * Here is the token struct. It is used for both the token linked-list and
- * env linked-list.
- */
-struct Token
-{
-	/*
-	 * For the token linked-list, this stores the token; for the env linked-list
-	 * this stores the value of the variable.
-	 */
-	char* value;
-	/*
-	 * Used only for the env linked-list. It holds a string containing the
-	 * name of the var.
-	 */
-	char* var;
-	/*
-	 * This struct stores a node of a singly linked list, store the pointer to
-	 * the next node.
-	 */
-	struct Token* next;
-};
-
-/* Token linked-list; stores the tokens of each line */
-struct Token* token;
-/* Env linked-list; stores the environment variables */
-struct Token* env;
diff --git a/Kaem/kaem.run b/Kaem/kaem.run
deleted file mode 100755
index 2b95ff5..0000000
--- a/Kaem/kaem.run
+++ /dev/null
@@ -1,59 +0,0 @@
-## Copyright (C) 2016 Jeremiah Orians
-## Copyright (C) 2020 fosslinux
-## This file is part of mescc-tools.
-##
-## mescc-tools is free software: you an redistribute it and/or modify
-## it under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## mescc-tools is distributed in the hope that it will be useful,
-## but WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with mescc-tools. If not, see <http://www.gnu.org/licenses/>.
-
-mkdir -p bin
-
-M2-Planet --architecture amd64 \
-	-f ../M2-Planet/test/common_amd64/functions/exit.c \
-	-f ../M2-Planet/test/common_amd64/functions/file.c \
-	-f functions/file_print.c \
-	-f ../M2-Planet/test/common_amd64/functions/malloc.c \
-	-f functions/calloc.c \
-	-f functions/match.c \
-	-f functions/string.c \
-	-f functions/in_set.c \
-	-f functions/require.c \
-	-f functions/numerate_number.c \
-	-f ../M2-Planet/test/common_amd64/functions/fork.c \
-	-f ../M2-Planet/test/common_amd64/functions/execve.c \
-	-f ../M2-Planet/test/common_amd64/functions/getcwd.c \
-	-f ../M2-Planet/test/common_amd64/functions/chdir.c \
-	-f kaem.h \
-	-f variable.c \
-	-f kaem.c \
-	--debug \
-	-o bin/kaem.M1
-
-blood-elf --64 -f bin/kaem.M1 -o bin/kaem-footer.M1
-
-M1 -f ../M2-Planet/test/common_amd64/amd64_defs.M1 \
-	-f ../M2-Planet/test/common_amd64/libc-core.M1 \
-	-f bin/kaem.M1 \
-	-f bin/kaem-footer.M1 \
-	--LittleEndian \
-	--architecture amd64 \
-	-o bin/kaem.hex2
-
-hex2 -f ../M2-Planet/test/common_amd64/ELF-amd64-debug.hex2 \
-	-f bin/kaem.hex2 \
-	--LittleEndian \
-	--architecture amd64 \
-	--BaseAddress 0x00600000 \
-	-o bin/kaem \
-	--exec_enable
-
-rm bin/kaem.M1 bin/kaem-footer.M1 bin/kaem.hex2
diff --git a/Kaem/makefile b/Kaem/makefile
deleted file mode 100644
index 18f9c65..0000000
--- a/Kaem/makefile
+++ /dev/null
@@ -1,57 +0,0 @@
-## Copyright (C) 2016 Jeremiah Orians
-## Copyright (C) 2020 fosslinux
-## This file is part of mescc-tools.
-##
-## mescc-tools is free software: you an redistribute it and/or modify
-## it under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## mescc-tools is distributed in the hope that it will be useful,
-## but WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with mescc-tools. If not, see <http://www.gnu.org/licenses/>.
-
-# Prevent rebuilding
-VPATH = ../bin:test/results
-
-all: kaem
-
-CC=gcc
-CFLAGS:=$(CFLAGS) -D_GNU_SOURCE -std=c99 -ggdb
-
-kaem: kaem.c | bin
-	$(CC) $(CFLAGS) kaem.c variable.c ../functions/file_print.c ../functions/match.c ../functions/in_set.c ../functions/string.c ../functions/require.c ../functions/numerate_number.c -o ../bin/kaem
-
-# Always run the tests
-.PHONY: test
-test: kaem | results
-	./test.sh
-
-# Generate test answers
-.PHONY: Generate-test-answers
-Generate-test-answers:
-	sha256sum test/results/* >| test/test.answers
-
-# Clean up after ourselves
-.PHONY: clean
-clean:
-	rm -rf ../bin/
-	rm -rf test/results/
-
-results:
-	mkdir -p test/results
-
-bin:
-	mkdir -p ../bin
-
-DESTDIR:=
-PREFIX:=/usr/local
-bindir:=$(DESTDIR)$(PREFIX)/bin
-.PHONY: install
-install: kaem
-	mkdir -p $(bindir)
-	cp $^ $(bindir)
diff --git a/Kaem/test.sh b/Kaem/test.sh
deleted file mode 100755
index 1b5df19..0000000
--- a/Kaem/test.sh
+++ /dev/null
@@ -1,25 +0,0 @@
-#!/bin/bash
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-
-echo "Starting kaem tests"
-for i in $(seq 0 15) ; do
-	TEST=$(printf "%02d" $i)
-	../bin/kaem -f "test/test${TEST}/kaem.test" >| "test/results/test${TEST}-output" 2>&1
-done
-. ../sha256.sh
-sha256_check test/test.answers
-echo "kaem tests complete"
diff --git a/Kaem/test/.gitignore b/Kaem/test/.gitignore
deleted file mode 100644
index fbca225..0000000
--- a/Kaem/test/.gitignore
+++ /dev/null
@@ -1 +0,0 @@
-results/
diff --git a/Kaem/test/test.answers b/Kaem/test/test.answers
deleted file mode 100644
index 32bc3b9..0000000
--- a/Kaem/test/test.answers
+++ /dev/null
@@ -1,16 +0,0 @@
-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  test/results/test00-output
-27e6f695d734689575e2a063b77668a1fab9c7a83071134630f6a02ebf697592  test/results/test01-output
-5400fc717d9b2543f5e24da4b2c52f196845455073fd7fcef704c792322a552c  test/results/test02-output
-5881f8af754d89e4b6f0cc5e65a0654444a83140946a83f7d5941e6236f180d2  test/results/test03-output
-8753402793cfecacc5b90b6c7c0f8b351c9be60fd7d07fe18cf4a189bfff16f3  test/results/test04-output
-8f434346648f6b96df89dda901c5176b10a6d83961dd3c1ac88b59b2dc327aa4  test/results/test05-output
-11b03bec7e7e57151b67cf4d3b38cc5cc9a0469549e104f58b9bf9de82f90c22  test/results/test06-output
-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  test/results/test07-output
-e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855  test/results/test08-output
-1e8496d3113042efaa03bdb8cf6140ece7d465452ead25f6d3ef4de01222470c  test/results/test09-output
-95dba24b284ededa4706f620de47763507d33cb0f639c18edd6927cdf6c74fc0  test/results/test10-output
-27ea77a39eab17e100e337eed5c4b7cacc63708278a298e172dbd103be1284b3  test/results/test11-output
-7dbd8549693776e6ded571d3cb887cd85fbce19fb8cfdfd525bbeb263817138c  test/results/test12-output
-5c4b79c9c70ce64d352196b2750dde4f1236e6085bcee2a470465b8a6fdd6cc6  test/results/test13-output
-1f6005ed0b7d4bea12c30b48d7286d9cc3ad6ad358bad9bdd492cab3ecaf2e50  test/results/test14-output
-7e613bc735fd7ae59b76ac2f90e704af63833943f0a3952f201387074d25d5f0  test/results/test15-output
diff --git a/Kaem/test/test00/kaem.test b/Kaem/test/test00/kaem.test
deleted file mode 100644
index 93def84..0000000
--- a/Kaem/test/test00/kaem.test
+++ /dev/null
@@ -1,18 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# This test tests line comments!
-# There should be no output.
diff --git a/Kaem/test/test01/kaem.test b/Kaem/test/test01/kaem.test
deleted file mode 100644
index b35cad0..0000000
--- a/Kaem/test/test01/kaem.test
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test execution of simple commands.
-printf hi
-printf hi
diff --git a/Kaem/test/test02/kaem.test b/Kaem/test/test02/kaem.test
deleted file mode 100644
index 03b4d1b..0000000
--- a/Kaem/test/test02/kaem.test
+++ /dev/null
@@ -1,18 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test echo
-echo hi
diff --git a/Kaem/test/test03/kaem.test b/Kaem/test/test03/kaem.test
deleted file mode 100644
index ca312e7..0000000
--- a/Kaem/test/test03/kaem.test
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test use of set -x
-set -x
-printf hi
diff --git a/Kaem/test/test04/kaem.test b/Kaem/test/test04/kaem.test
deleted file mode 100644
index 4051a11..0000000
--- a/Kaem/test/test04/kaem.test
+++ /dev/null
@@ -1,20 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test use of set -e
-set -e
-thiscommanddoesnotexist
-printf hi
diff --git a/Kaem/test/test05/kaem.test b/Kaem/test/test05/kaem.test
deleted file mode 100644
index 349d327..0000000
--- a/Kaem/test/test05/kaem.test
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test non existent commands without set -e
-thiscommanddoesnotexist
-printf hi
diff --git a/Kaem/test/test06/kaem.test b/Kaem/test/test06/kaem.test
deleted file mode 100644
index 6d8ea81..0000000
--- a/Kaem/test/test06/kaem.test
+++ /dev/null
@@ -1,20 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test use of multiple arguments with set
-set -ex
-thiscommanddoesnotexist
-printf hi
diff --git a/Kaem/test/test07/kaem.test b/Kaem/test/test07/kaem.test
deleted file mode 100644
index a58940f..0000000
--- a/Kaem/test/test07/kaem.test
+++ /dev/null
@@ -1,18 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# This is meant to test pwd.
-# But I don't have a very good way to test it yet...
diff --git a/Kaem/test/test08/kaem.test b/Kaem/test/test08/kaem.test
deleted file mode 100644
index 6590a74..0000000
--- a/Kaem/test/test08/kaem.test
+++ /dev/null
@@ -1,18 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test adding of an envar
-VAR=text
diff --git a/Kaem/test/test09/kaem.test b/Kaem/test/test09/kaem.test
deleted file mode 100644
index 56bb951..0000000
--- a/Kaem/test/test09/kaem.test
+++ /dev/null
@@ -1,18 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test RAW strings
-echo "raw string"
diff --git a/Kaem/test/test10/kaem.test b/Kaem/test/test10/kaem.test
deleted file mode 100644
index ba5caf3..0000000
--- a/Kaem/test/test10/kaem.test
+++ /dev/null
@@ -1,21 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test simple variable substitution
-VAR=text
-ANOTHER=more
-echo text-${VAR}-${ANOTHER}-text
-../bin/kaem -f test/test10/subkaem.test
diff --git a/Kaem/test/test10/subkaem.test b/Kaem/test/test10/subkaem.test
deleted file mode 100644
index 713d43f..0000000
--- a/Kaem/test/test10/subkaem.test
+++ /dev/null
@@ -1,18 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test simple variable substitution, passed to another kaem
-echo text-${VAR}-${ANOTHER}-text
diff --git a/Kaem/test/test11/kaem.test b/Kaem/test/test11/kaem.test
deleted file mode 100644
index 6c131c4..0000000
--- a/Kaem/test/test11/kaem.test
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test variable subsitution with :- where the var exists
-VAR=exists
-echo ${VAR:-not}
diff --git a/Kaem/test/test12/kaem.test b/Kaem/test/test12/kaem.test
deleted file mode 100644
index 8f7665d..0000000
--- a/Kaem/test/test12/kaem.test
+++ /dev/null
@@ -1,18 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test variable subsitution with :- where the variable does not exist
-echo ${VAR:-not}
diff --git a/Kaem/test/test13/kaem.test b/Kaem/test/test13/kaem.test
deleted file mode 100644
index c836753..0000000
--- a/Kaem/test/test13/kaem.test
+++ /dev/null
@@ -1,18 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test substitution of $@
-echo $@ -- foo
diff --git a/Kaem/test/test14/kaem.test b/Kaem/test/test14/kaem.test
deleted file mode 100644
index 3fdd5cf..0000000
--- a/Kaem/test/test14/kaem.test
+++ /dev/null
@@ -1,19 +0,0 @@
-# Copyright (C) 2020 fosslinux
-# This file is part of mescc-tools.
-#
-# mescc-tools is free software: you can redistribute it and/or modify
-# it under the terms of the GNU General Public License as published by
-# the Free Software Foundation, either version 3 of the License, or
-# (at your option) any later version.
-#
-# mescc-tools is distributed in the hope that it will be useful,
-# but WITHOUT ANY WARRANTY; without even the implied warranty of
-# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-# GNU General Public License for more details.
-#
-# You should have received a copy of the GNU General Public License
-# along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
-#
-# Test end-of-line escapes
-printf \
-    "hi"
diff --git a/Kaem/test/test15/kaem.test b/Kaem/test/test15/kaem.test
deleted file mode 100644
index bfc2d98..0000000
--- a/Kaem/test/test15/kaem.test
+++ /dev/null
@@ -1,6 +0,0 @@
-VAR=test
-ANOTHER=test2
-echo ${VAR}
-unset VAR ANOTHER
-echo ${VAR}
-echo ${ANOTHER}
diff --git a/Kaem/variable.c b/Kaem/variable.c
deleted file mode 100644
index 37ee6f8..0000000
--- a/Kaem/variable.c
+++ /dev/null
@@ -1,284 +0,0 @@
-/*
- * Copyright (C) 2020 fosslinux
- * This file is part of mescc-tools.
- *
- * mescc-tools is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * mescc-tools is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <stdlib.h>
-#include <stdio.h>
-#include <unistd.h>
-#include "kaem.h"
-
-/* Prototypes from other files */
-int array_length(char** array);
-char* env_lookup(char* variable);
-
-/*
- * VARIABLE HANDLING FUNCTIONS
- */
-
-/* Substitute a variable into n->value */
-int run_substitution(char* var_name, struct Token* n)
-{
-	char* value = env_lookup(var_name);
-	/* If there is nothing to substitute, don't substitute anything! */
-	if(value != NULL)
-	{
-		n->value = prepend_string(n->value, value);
-		return TRUE;
-	}
-	return FALSE;
-}
-
-/* Handle ${var:-text} format of variables - i.e. ifset format */
-int variable_substitute_ifset(char* input, struct Token* n, int index)
-{
-	/*
-	 * In ${var:-text} format, we evaluate like follows.
-	 * If var is set as an envar, then we substitute the contents of that
-	 * envar. If it is not set, we substitute alternative text.
-	 *
-	 * In this function, we assume that input is the raw token,
-	 * n->value is everything already done in variable_substitute,
-	 * index is where we are up to in input. offset is for n->value.
-	 */
-
-	/* 
-	 * Check if we should even be performing this function.
-	 * We perform this function when we come across ${var:-text} syntax.
-	 */
-	int index_old = index;
-	int perform = FALSE;
-	int input_length = string_length(input);
-	while(index < input_length)
-	{ /* Loop over each character */
-		if(input[index] == ':' && input[index + 1] == '-')
-		{ /* Yes, this is (most likely) ${var:-text} format. */
-			perform = TRUE;
-			break;
-		}
-		index = index + 1;
-	}
-
-	/* Don't perform it if we shouldn't */
-	if(perform == FALSE) return index_old;
-	index = index_old;
-	
-	/* 
-	 * Get offset.
-	 * offset is the difference between the index of the variable we write to
-	 * in the following blocks and input.
-	 * This stays relatively constant.
-	 */
-	int offset = index;
-
-	/* Get the variable name */
-	char* var_name = calloc(MAX_STRING, sizeof(char));
-	require(var_name != NULL, "Memory initialization of var_name in variable_substitute_ifset failed\n");
-	while(input[index] != ':')
-	{ /* Copy into var_name until :- */
-		var_name[index - offset] = input[index];
-		index = index + 1;
-	}
-
-	/* Skip over :- */
-	index = index + 2;
-	offset = index;
-
-	/* Get the alternative text */
-	char* text = calloc(MAX_STRING, sizeof(char));
-	require(text != NULL, "Memory initialization of text in variable_substitute_ifset failed\n");
-	while(input[index] != '}')
-	{ /* Copy into text until } */
-		require(input_length > index, "IMPROPERLY TERMINATED VARIABLE\nABORTING HARD\n");
-		text[index - offset] = input[index];
-		index = index + 1;
-	}
-
-	/* Do the substitution */
-	if(run_substitution(var_name, n) == FALSE)
-	{ /* The variable was not found. Substitute the alternative text. */
-		n->value = prepend_string(n->value, text);
-	}
-
-	return index;
-}
-
-/* Controls substitution for ${variable} and derivatives */
-int variable_substitute(char* input, struct Token* n, int index)
-{
-	/* NOTE: index is the pos of input */
-	index = index + 1; /* We don't want the { */
-
-	/* 
-	 * Check for "special" types
-	 * If we do find a special type we delegate the substitution to it
-	 * and return here; as we are done... there's nothing more do do in
-	 * that case.
-	 */
-	int index_old = index;
-	index = variable_substitute_ifset(input, n, index);
-	if(index != index_old) return index;
-
-	/* Reset index */
-	index = index_old;
-
-	/* 
-	 * If we reach here it is a normal substitution
-	 * Let's do it!
-	 */
-	/* Initialize var_name and offset */
-	char* var_name = calloc(MAX_STRING, sizeof(char));
-	require(var_name != NULL, "Memory initialization of var_name in variable_substitute failed\n");
-	int offset = index;
-
-	/* Get the variable name */
-	int substitute_done = FALSE;
-	while(substitute_done == FALSE)
-	{
-		char c = input[index];
-		require(MAX_STRING > index, "LINE IS TOO LONG\nABORTING HARD\n");
-		if(EOF == c || '\n' == c || index > string_length(input))
-		{ /* We never should hit EOF, EOL or run past the end of the line 
-			 while collecting a variable */
-			file_print("IMPROPERLY TERMINATED VARIABLE!\nABORTING HARD\n", stderr);
-			exit(EXIT_FAILURE);
-		}
-		else if('\\' == c)
-		{ /* Drop the \ - poor mans escaping. */
-			index = index + 1;
-		}
-		else if('}' == c)
-		{ /* End of variable name */
-			substitute_done = TRUE;
-		}
-		else
-		{
-			var_name[index - offset] = c;
-			index = index + 1;
-		}
-	}
-
-	/* Substitute the variable */
-	run_substitution(var_name, n);
-
-	return index;
-}
-
-/* Function to concatenate all command line arguments */
-void variable_all(char** argv, struct Token* n)
-{
-	fflush(stdout);
-	/* index refernences the index of n->value, unlike other functions */
-	int index = 0;
-	int argv_length = array_length(argv);
-	int i;
-	int j;
-	char* argv_element = calloc(MAX_STRING, sizeof(char));
-	char* hold;
-	n->value = argv_element;
-	/* Assuming the form kaem -f script or kaem -f script -- 123 we want matching results to bash, so skip the kaem, -f and script */
-	for(i = 3; i < argv_length; i = i + 1)
-	{
-		/* Ends up with (n->value) (argv[i]) */
-		/* If we don't do this we get jumbled results in M2-Planet */
-		hold = argv[i];
-		copy_string(argv_element + index, argv[i]);
-		index = string_length(argv_element);
-		if(match(hold, "--"))
-		{ /* -- signifies everything after this */
-			/* Reset n->value */
-			for(j = index; j >= 0; j = j - 1)
-			{
-				n->value[j] = 0;
-			}
-			copy_string(argv_element, argv[i]);
-			index = string_length(argv_element);
-		}
-
-		/* Add space on the end */
-		n->value[index] = ' ';
-		index = index + 1;
-	}
-	/* Remove trailing space */
-	index = index - 1;
-	n->value[index] = 0;
-}
-
-/* Function controlling substitution of variables */
-void handle_variables(char** argv, struct Token* n)
-{
-	/* NOTE: index is the position of input */
-	int index = 0;
-
-	/* Create input */
-	char* input = calloc(MAX_STRING, sizeof(char));
-	require(input != NULL, "Memory initialization of input in collect_variable failed\n");
-	copy_string(input, n->value);
-	/* Reset n->value */
-	n->value = calloc(MAX_STRING, sizeof(char));
-	require(n->value != NULL, "Memory initialization of n->value in collect_variable failed\n");
-
-	/* Copy everything up to the $ */
-	/* 
-	 * TODO: Not need allocation of input before this check if there is no
-	 * variable in it.
-	 */
-	while(input[index] != '$')
-	{
-		if(input[index] == 0)
-		{ /* No variable in it */
-			n->value = input;
-			return; /* We don't need to do anything more */
-		}
-		n->value[index] = input[index];
-		index = index + 1;
-	}
-
-	/* Must be outside the loop */
-	int offset;
-
-substitute:
-	index = index + 1; /* We are uninterested in the $ */
-	/* Run the substitution */
-	if(input[index] == '{')
-	{ /* Handle everything ${ related */
-		index = variable_substitute(input, n, index);
-		index = index + 1; /* We don't want the closing } */
-	}
-	else if(input[index] == '@')
-	{ /* Handles $@ */
-		index = index + 1; /* We don't want the @ */
-		variable_all(argv, n);
-	}
-	else
-	{ /* We don't know that */
-		file_print("IMPROPERLY USED VARIABLE!\nOnly ${foo} and $@ format are accepted at this time.\nABORTING HARD\n", stderr);
-		exit(EXIT_FAILURE);
-	}
-
-	offset = string_length(n->value) - index;
-	/* Copy everything from the end of the variable to the end of the token */
-	while(input[index] != 0)
-	{
-		if(input[index] == '$')
-		{ /* We have found another variable */
-			fflush(stdout);
-			goto substitute;
-		}
-		n->value[index + offset] = input[index];
-		index = index + 1;
-	}
-}
diff --git a/kaem.c b/kaem.c
new file mode 100644
index 0000000..a866fbb
--- /dev/null
+++ b/kaem.c
@@ -0,0 +1,705 @@
+/* Copyright (C) 2016 Jeremiah Orians
+ * This file is part of mescc-tools.
+ *
+ * mescc-tools is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * mescc-tools is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with mescc-tools.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+#define FALSE 0
+//CONSTANT FALSE 0
+#define TRUE 1
+//CONSTANT TRUE 1
+#define MAX_STRING 4096
+//CONSTANT MAX_STRING 4096
+#define MAX_ARGS 256
+//CONSTANT MAX_ARGS 256
+
+char* collect_token(FILE* input);
+char* collect_variable(char* input, char** envp, char** argv);
+char* copy_string(char* target, char* source);
+char* env_lookup(char* token, char** envp);
+char* find_char(char* string, char a);
+char* find_executable(char* name, char* PATH);
+char* get_current_dir_name();
+char* numerate_number(int a);
+char* postpend_char(char* s, char a);
+char* prematch(char* search, char* field);
+char* prepend_string(char* add, char* base);
+int check_envar(char* token);
+int match(char* a, char* b);
+int string_length(char* a);
+void cd(char* path);
+void collect_comment(FILE* input);
+void collect_string(FILE* input, char* target);
+void execute_commands(FILE* script, char** envp, char** argv);
+void file_print(char* s, FILE* f);
+void require(int bool, char* error);
+void set(char** tokens);
+
+int command_done;
+int VERBOSE;
+int STRICT;
+int envp_length;
+int i_input;
+int i_token;
+
+/* Function for purging line comments */
+void collect_comment(FILE* input)
+{
+	int c;
+	do
+	{
+		c = fgetc(input);
+		if(-1 == c)
+		{
+			file_print("IMPROPERLY TERMINATED LINE COMMENT!\nABORTING HARD\n", stderr);
+			exit(EXIT_FAILURE);
+		}
+	} while('\n' != c);
+}
+
+/* Function for collecting RAW strings and removing the " that goes with them */
+void collect_string(FILE* input, char* target)
+{
+	int c;
+	do
+	{
+		require(MAX_STRING > i_input, "LINE IS TOO LONG\nABORTING HARD\n");
+		require(MAX_STRING > i_token, "LINE IS TOO LONG\nABORTING HARD\n");
+		c = fgetc(input);
+		if(-1 == c)
+		{ /* We never should hit EOF while collecting a RAW string */
+			file_print("IMPROPERLY TERMINATED RAW string!\nABORTING HARD\n", stderr);
+			exit(EXIT_FAILURE);
+		}
+		else if('"' == c)
+		{ /* Made it to the end */
+			c = 0;
+		}
+		target[i_token] = c;
+		i_token = i_token + 1;
+		i_input = i_input + 1;
+	} while(0 != c);
+}
+
+/* Function to collect an individual argument or purge a comment */
+char* collect_token(FILE* input)
+{
+	char* token = calloc(MAX_STRING, sizeof(char));
+	char c;
+	i_input = 0;
+	i_token = 0;
+	do
+	{
+		c = fgetc(input);
+		/* Bounds checking */
+		require(MAX_STRING > i_input, "LINE IS TOO LONG\nABORTING HARD\n");
+		require(MAX_STRING > i_token, "LINE IS TOO LONG\nABORTING HARD\n");
+		if(-1 == c)
+		{ /* Deal with end of file */
+			file_print("execution complete\n", stderr);
+			exit(EXIT_SUCCESS);
+		}
+		else if((' ' == c) || ('\t' == c))
+		{ /* space and tab are token seperators */
+			c = 0;
+		}
+		else if('\n' == c)
+		{ /* Command terminates at end of line */
+			c = 0;
+			command_done = 1;
+		}
+		else if('"' == c)
+		{ /* RAW strings are everything between a pair of "" */
+			collect_string(input, token);
+			c = 0;
+		}
+		else if('#' == c)
+		{ /* Line comments to aid the humans */
+			collect_comment(input);
+			c = 0;
+			command_done = 1;
+		}
+		else if('\\' == c)
+		{ /* Support for end of line escapes, drops the char after */
+			fgetc(input);
+			c = 0;
+		}
+		token[i_token] = c;
+		i_token = i_token + 1;
+		i_input = i_input + 1;
+	} while (0 != c);
+
+	if(1 >= i_input)
+	{ /* Nothing worth returning */
+		free(token);
+		return NULL;
+	}
+	return token;
+}
+
+char* find_char(char* string, char a)
+{
+	if(0 == string[0]) return NULL;
+	while(a != string[0])
+	{
+		string = string + 1;
+		if(0 == string[0]) return string;
+	}
+	return string;
+}
+
+char* prematch(char* search, char* field)
+{
+	do
+	{
+		if(search[0] != field[0]) return NULL;
+		search = search + 1;
+		field = field + 1;
+	} while(0 != search[0]);
+	return field;
+}
+
+int array_length(char** array)
+{
+	int length = 0;
+	while(array[length] != NULL)
+	{
+		length = length + 1;
+	}
+	return length;
+}
+
+char* env_lookup(char* token, char** envp)
+{
+	if(NULL == envp) return NULL;
+	int i = 0;
+	char* ret = NULL;
+	do
+	{
+		ret = prematch(token, envp[i]);
+		if(NULL != ret) return ret;
+		i = i + 1;
+	} while(0 != envp[i]);
+	return NULL;
+}
+
+char* find_executable(char* name, char* PATH)
+{
+	if(('.' == name[0]) || ('/' == name[0]))
+	{ /* assume names that start with . or / are relative or absolute */
+		return name;
+	}
+
+	char* next = find_char(PATH, ':');
+	char* trial = calloc(MAX_STRING, sizeof(char));
+	FILE* t = NULL;
+	while(NULL != next)
+	{
+		next[0] = 0;
+		trial = prepend_string(PATH, prepend_string("/", name));
+
+		t = fopen(trial, "r");
+		if(NULL != t)
+		{
+			fclose(t);
+			return trial;
+		}
+		PATH = next + 1;
+		next = find_char(PATH, ':');
+		free(trial);
+	}
+	return NULL;
+}
+
+/* Function to check if the token is an envar */
+int check_envar(char* token)
+{
+	int j;
+	int equal_found;
+	equal_found = 0;
+	for(j = 0; j < string_length(token); j = j + 1)
+	{
+		if(token[j] == '=')
+		{ /* After = can be anything */
+			equal_found = 1;
+			break;
+		}
+		else
+		{ /* Should be A-z */
+			int found;
+			found = 0;
+			char c;
+			/* Represented numerically; 0 = 48 through 9 = 57 */
+			for(c = 48; c <= 57; c = c + 1)
+			{
+				if(token[j] == c)
+				{
+					found = 1;
+				}
+			}
+			/* Represented numerically; A = 65 through z = 122 */
+			for(c = 65; c <= 122; c = c + 1)
+			{
+				if(token[j] == c)
+				{
+					found = 1;
+				}
+			}
+			if(found == 0)
+			{ /* In all likelihood this isn't actually an environment variable */
+				return 1;
+			}
+		}
+	}
+	if(equal_found == 0)
+	{ /* Not an envar */
+		return 1;
+	}
+	return 0;
+}
+
+/* cd builtin */
+void cd(char* path)
+{
+	require(NULL != path, "INVALID CD PATH\nABORTING HARD\n");
+	chdir(path);
+}
+
+/* pwd builtin */
+void pwd()
+{
+	file_print(get_current_dir_name(), stdout);
+	file_print("\n", stdout);
+}
+
+/* set builtin */
+void set(char** tokens)
+{
+	/* Get the options */
+	char* raw = calloc(MAX_STRING, sizeof(char));
+	copy_string(raw, tokens[1]);
+	char* options = calloc(MAX_STRING, sizeof(char));
+	int i;
+	for(i = 0; i < string_length(raw) - 1; i = i + 1)
+	{
+		options[i] = raw[i + 1];
+	}
+	/* Parse the options */
+	for(i = 0; i < string_length(options); i = i + 1)
+	{
+		if(options[i] == 'a')
+		{ /* set -a is on by default and cannot be disabled at this time */
+			continue;
+		}
+		else if(options[i] == 'e')
+		{ /* Fail on failure */
+			STRICT = TRUE;
+		}
+		else if(options[i] == 'v')
+		{ /* Same as -x currently */
+			options[i] = 'x';
+			continue;
+		}
+		else if(options[i] == 'x')
+		{ /* Show commands as executed */
+			/* TODO: this currently behaves like -v. Make it do what it should */
+			VERBOSE = TRUE;
+			file_print(" +> set -x\n", stdout);
+		}
+		else
+		{
+			char* erroneous_option = calloc(2, sizeof(char));
+			erroneous_option[0] = options[i];
+			file_print(erroneous_option, stderr);
+			file_print(" is an invalid set option!\n", stderr);
+			exit(EXIT_FAILURE);
+		}
+	}
+}
+
+/* echo builtin */
+void echo(char** tokens)
+{
+	int i;
+	for(i = 1; i < array_length(tokens); i = i + 1)
+	{
+		file_print(tokens[i], stdout);
+		file_print(" ", stdout);
+	}
+	file_print("\n", stdout);
+}
+
+int execute(char** tokens, char** envp, char* PATH)
+{
+	int status;
+	char* program = find_executable(tokens[0], PATH);
+	if(NULL == program)
+	{
+		file_print(tokens[0], stderr);
+		file_print("\nfailed to execute\n", stderr);
+		exit(EXIT_FAILURE);
+	}
+
+	int f = fork();
+	if (f == -1)
+	{
+		file_print("fork() failure", stderr);
+		exit(EXIT_FAILURE);
+	}
+	else if (f == 0)
+	{ /* child */
+		/* execve() returns only on error */
+		execve(program, tokens, envp);
+		/* Prevent infinite loops */
+		_exit(EXIT_SUCCESS);
+	}
+
+	/* Otherwise we are the parent */
+	/* And we should wait for it to complete */
+	waitpid(f, &status, 0);
+
+	return status;
+}
+
+char* variable_substitute(char* input, char** envp)
+{
+	char* output = calloc(MAX_STRING, sizeof(char));
+	char* var_name = calloc(MAX_STRING, sizeof(char));
+	int eval_var = 0;
+	int i = 2;
+	while(i < string_length(input))
+	{
+		char c = input[i];
+		require(MAX_STRING > i_input, "LINE IS TOO LONG\nABORTING HARD\n");
+		require(MAX_STRING > i_token, "LINE IS TOO LONG\nABORTING HARD\n");
+		if(-1 == c)
+		{ /* We never should hit EOF while collecting a variable */
+			file_print("IMPROPERLY TERMINATED VARIABLE!\nABORTING HARD\n", stderr);
+			exit(EXIT_FAILURE);
+		}
+		else if('\n' == c)
+		{ /* Why are we hitting a EOL */
+			file_print("IMPROPERLY TERMINATED VARIABLE!\nABORTING HARD\n", stderr);
+			exit(EXIT_FAILURE);
+		}
+		else if('\\' == c)
+		{ /* Drop the char after */
+			i = i + 2;
+		}
+		else if(':' == c)
+		{ /* Special stuff */
+			i = i + 1;
+			c = input[i];
+			if('-' == c)
+			{ /* ${var1-$var2} if var1 is unset substitute var2 */
+				var_name = postpend_char(var_name, '=');
+				if(env_lookup(var_name, envp) == NULL)
+				{ /* var1 is unset */
+					memset(var_name, 0, MAX_STRING);
+					var_name = ""; /* Reset and get the rest */
+					eval_var = 1;
+				}
+				else
+				{
+					/* We've collected everything */
+					break;
+				}
+				i = i + 1;
+			}
+			else
+			{
+				var_name = postpend_char(var_name, input[i - 1]);
+			}
+		}
+		else if('}' == c)
+		{ /* End of variable name */
+			if(eval_var == 0)
+			{
+				var_name = postpend_char(var_name, '=');
+			}
+			break;
+		}
+		else
+		{
+			var_name = postpend_char(var_name, c);
+			i = i + 1;
+		}
+	}
+
+	/* Substitute the variable */
+	if(eval_var == 0)
+	{
+		output = env_lookup(var_name, envp);
+		if(output == NULL)
+		{
+			output = "";
+		}
+	}
+	else
+	{
+		copy_string(output, var_name);
+	}
+
+	return output;
+}
+
+/* Function to concatanate all variables */
+char* variable_all(char** argv)
+{
+	char* output = calloc(MAX_STRING, sizeof(char));
+	int i;
+	int length = array_length(argv);
+	for(i = 0; i < length; i = i + 1)
+	{
+		output = prepend_string(output, argv[i]);
+		output = prepend_string(output, " ");
+	}
+	return output;
+}
+
+
+/* Function to substitute variables */
+char* collect_variable(char* input, char** envp, char** argv)
+{
+	if(input[0] != '$')
+	{
+		char* output = calloc(MAX_STRING, sizeof(char));
+		copy_string(output, input);
+		return output;
+	}
+
+	if(input[1] == '{')
+	{
+		return variable_substitute(input, envp);
+	}
+	else if(input[1] == '@')
+	{
+		return variable_all(argv);
+	}
+	else
+	{
+		file_print("IMPROPERLY USED VARIABLE!\nABORTING HARD\n", stderr);
+		exit(EXIT_FAILURE);
+	}
+
+	/* Get the name of the variable */
+}
+
+/* Function for executing our programs with desired arguments */
+void execute_commands(FILE* script, char** envp, char** argv)
+{
+	while(1)
+	{
+		char** tokens = calloc(MAX_ARGS, sizeof(char*));
+
+		char* PATH = env_lookup("PATH=", envp);
+		if(NULL != PATH)
+		{
+			PATH = calloc(MAX_STRING, sizeof(char));
+			copy_string(PATH, env_lookup("PATH=", envp));
+		}
+
+		char* USERNAME = env_lookup("LOGNAME=", envp);
+		if((NULL == PATH) && (NULL == USERNAME))
+		{
+			PATH = calloc(MAX_STRING, sizeof(char));
+			copy_string(PATH, "/root/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin");
+		}
+		else if(NULL == PATH)
+		{
+			PATH = prepend_string("/home/", prepend_string(USERNAME,"/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games"));
+		}
+
+		int i = 0;
+		command_done = 0;
+		do
+		{
+			char* result = collect_token(script);
+			if(NULL != result)
+			{ /* Not a comment string but an actual argument */
+				if(i >= MAX_ARGS)
+				{ /* Prevent segfaults */
+					file_print("Script too long\n", stderr);
+					exit(EXIT_FAILURE);
+				}
+				tokens[i] = result;
+				i = i + 1;
+			}
+		} while(0 == command_done);
+
+		if(VERBOSE && (0 < i))
+		{
+			file_print(" +> ", stdout);
+			int j;
+			for(j = 0; j < i; j = j + 1)
+			{
+				file_print(tokens[j], stdout);
+				fputc(' ', stdout);
+			}
+			file_print("\n", stdout);
+		}
+
+		int j = 0;
+		while(tokens[j] != NULL)
+		{
+			char* output = collect_variable(tokens[j], envp, argv);
+			memset(tokens[j], 0, MAX_STRING);
+			copy_string(tokens[j], output);
+			j = j + 1;
+		}
+
+		if(0 < i)
+		{ /* Not a line comment */
+			/* Find what it is */
+			if(check_envar(tokens[0]) == 0)
+			{ /* It's an envar! */
+				if(string_length(tokens[0]) > MAX_STRING)
+				{ /* String is too long; prevent buffer overflow */
+					file_print(tokens[0], stderr);
+					file_print("\nis too long to fit in envp\n", stderr);
+				}
+				envp[envp_length] = tokens[0]; /* Since arrays are 0 indexed */
+				envp_length = envp_length + 1;
+			}
+			else if(match(tokens[0], "cd"))
+			{ /* cd builtin */
+				cd(tokens[1]);
+			}
+			else if(match(tokens[0], "pwd"))
+			{ /* pwd builtin */
+				pwd();
+			}
+			else if(match(tokens[0], "set"))
+			{ /* set builtin */
+				set(tokens);
+			}
+			else if(match(tokens[0], "echo"))
+			{ /* echo builtin */
+				echo(tokens);
+			}
+			else if(match(tokens[0], ""))
+			{ /* Well, that's weird, but can happen, and leads to segfaults in exec */
+				file_print("hit edge case\nReport what caused this\n", stderr);
+				continue;
+			}
+			else
+			{ /* Stuff to exec */
+				int status = execute(tokens, envp, PATH);
+				if(STRICT && (0 != status))
+				{ /* Clearly the script hit an issue that should never have happened */
+					file_print("Subprocess error ", stderr);
+					file_print(numerate_number(status), stderr);
+					file_print("\nABORTING HARD\n", stderr);
+					/* stop to prevent damage */
+					exit(EXIT_FAILURE);
+				}
+			}
+		}
+		/* Does nothing in M2-Planet but otherwise GCC-compiled kaem segfaults */
+		free(tokens);
+		/* Then go again */
+	}
+}
+
+
+int main(int argc, char** argv, char** envp)
+{
+	VERBOSE = FALSE;
+	STRICT = FALSE;
+	char* filename = "kaem.run";
+	FILE* script = NULL;
+
+	/* Get envp_length */
+	envp_length = 1;
+	while(envp[envp_length] != NULL)
+	{
+		envp_length = envp_length + 1;
+	}
+	char** nenvp = calloc(envp_length + MAX_ARGS, sizeof(char*));
+	int i;
+	for(i = 0; i < envp_length; i = i + 1)
+	{
+		nenvp[i] = envp[i];
+	}
+
+	for(i = envp_length; i < (envp_length + MAX_ARGS); i = i + 1)
+	{
+		nenvp[i] = 0;
+	}
+
+	i = 1;
+	while(i <= argc)
+	{
+		if(NULL == argv[i])
+		{
+			i = i + 1;
+		}
+		else if(match(argv[i], "-h") || match(argv[i], "--help"))
+		{
+			file_print("kaem only accepts --help, --version, --file, --verbose, --nightmare-mode or no arguments\n", stdout);
+			exit(EXIT_SUCCESS);
+		}
+		else if(match(argv[i], "-f") || match(argv[i], "--file"))
+		{
+			filename = argv[i + 1];
+			i = i + 2;
+		}
+		else if(match(argv[i], "n") || match(argv[i], "--nightmare-mode"))
+		{
+			file_print("Begin nightmare", stdout);
+			envp = NULL;
+			i = i + 1;
+		}
+		else if(match(argv[i], "-V") || match(argv[i], "--version"))
+		{
+			file_print("kaem version 1.0.1 minimal\n", stdout);
+			exit(EXIT_SUCCESS);
+		}
+		else if(match(argv[i], "--verbose"))
+		{
+			VERBOSE = TRUE;
+			i = i + 1;
+		}
+		else if(match(argv[i], "--strict"))
+		{
+			STRICT = TRUE;
+			i = i + 1;
+		}
+		else
+		{
+			file_print("UNKNOWN ARGUMENT\n", stdout);
+			exit(EXIT_FAILURE);
+		}
+	}
+
+	script = fopen(filename, "r");
+
+	if(NULL == script)
+	{
+		file_print("The file: ", stderr);
+		file_print(filename, stderr);
+		file_print(" can not be opened!\n", stderr);
+		exit(EXIT_FAILURE);
+	}
+
+	execute_commands(script, nenvp, argv);
+	fclose(script);
+	return EXIT_SUCCESS;
+}
diff --git a/makefile b/makefile
index 8511a51..b00a53c 100644
--- a/makefile
+++ b/makefile
@@ -46,8 +46,8 @@ get_machine: get_machine.c | bin
 blood-elf: blood-elf.c functions/file_print.c functions/match.c functions/require.c functions/numerate_number.c | bin
 	$(CC) $(CFLAGS) blood-elf.c functions/file_print.c functions/match.c functions/require.c functions/in_set.c functions/numerate_number.c -o bin/blood-elf
 
-kaem: functions/file_print.c functions/string.c functions/require.c functions/match.c functions/in_set.c functions/numerate_number.c Kaem/kaem.c | bin
-	cd Kaem && make kaem
+kaem: functions/file_print.c functions/string.c functions/require.c functions/match.c functions/in_set.c functions/numerate_number.c kaem.c | bin
+	$(CC) $(CFLAGS) functions/file_print.c functions/string.c functions/require.c functions/match.c functions/in_set.c functions/numerate_number.c kaem.c -o bin/kaem
 
 catm: catm.c functions/file_print.c | bin
 	$(CC) $(CFLAGS) catm.c functions/file_print.c -o bin/catm
@@ -67,7 +67,6 @@ clean:
 	./test/test9/cleanup.sh
 	./test/test10/cleanup.sh
 	./test/test11/cleanup.sh
-	cd Kaem && make clean
 
 # A cleanup option we probably don't need
 .PHONY: clean-hard
diff --git a/test.sh b/test.sh
index 2b8efca..1f49831 100755
--- a/test.sh
+++ b/test.sh
@@ -19,5 +19,4 @@ set -ex
 . ./sha256.sh
 echo "Beginning mescc-tools-tests"
 sha256_check test/test.answers
-cd Kaem && make test
 echo "mescc-tools-tests done"
-- 
2.20.1

