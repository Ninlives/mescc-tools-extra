From 07ee787df1dcd98801abe8ecbebff11e11598472 Mon Sep 17 00:00:00 2001
From: Jeremiah Orians <jeremiah@pdp10.guru>
Date: Sat, 17 Oct 2020 21:54:43 -0400
Subject: [PATCH 15/17] speeding up M1

---
 M1-macro.c              | 277 +++++++++++++++++++++++++---------------
 test/test2/proof.answer |   2 +-
 2 files changed, 178 insertions(+), 101 deletions(-)

diff --git a/M1-macro.c b/M1-macro.c
index 8ffcf95..1a1e388 100644
--- a/M1-macro.c
+++ b/M1-macro.c
@@ -24,8 +24,8 @@
 
 //CONSTANT max_string 4096
 #define max_string 4096
-//CONSTANT MACRO 1
-#define MACRO 1
+//CONSTANT PROCESSED 1
+#define PROCESSED 1
 //CONSTANT STR 2
 #define STR 2
 //CONSTANT NEWLINE 3
@@ -65,6 +65,22 @@ int string_length(char* a);
 void file_print(char* s, FILE* f);
 void require(int bool, char* error);
 
+struct blob
+{
+	struct blob* next;
+	int type;
+	char* Text;
+	char* Expression;
+	struct blob* hash_next;
+};
+
+struct Token
+{
+	struct Token* next;
+	struct blob* contents;
+	char* filename;
+	int linenumber;
+};
 
 /* Globals */
 FILE* source_file;
@@ -74,6 +90,13 @@ int BigBitEndian;
 int ByteMode;
 int Architecture;
 int linenumber;
+struct Token* token_list;
+struct blob* blob_list;
+struct blob* define_blob;
+struct blob* newline_blob;
+int blob_count;
+char* SCRATCH;
+struct blob** hash_table;
 
 void line_error(char* filename, int linenumber)
 {
@@ -83,15 +106,67 @@ void line_error(char* filename, int linenumber)
 	file_print(" :", stderr);
 }
 
-struct Token
+void ClearScratch()
 {
-	struct Token* next;
-	int type;
-	char* Text;
-	char* Expression;
-	char* filename;
-	int linenumber;
-};
+	int i = 0;
+	int c = SCRATCH[i];
+	while(0 != c)
+	{
+		SCRATCH[i] = 0;
+		i = i + 1;
+		c = SCRATCH[i];
+	}
+}
+
+int GetHash(char* s)
+{
+	int i = 5381;
+	while(0 != s[0])
+	{
+		i = (i << 5) + i + s[0];
+		s = s + 1;
+	}
+	return i & 0xFFFF;
+}
+
+struct blob* FindBlob()
+{
+	int hash = GetHash(SCRATCH);
+	struct blob* i = hash_table[hash];
+	while(NULL != i)
+	{
+		if(match(SCRATCH, i->Text)) return i;
+		i = i->hash_next;
+	}
+
+	return NULL;
+}
+
+void AddHash(struct blob* a, char* s)
+{
+	int i = GetHash(s);
+	a->hash_next = hash_table[i];
+	hash_table[i] = a;
+}
+
+void NewBlob(int size)
+{
+	blob_count = blob_count + 1;
+	struct blob* a = calloc(1, sizeof(struct blob));
+	require(NULL != a, "Exhusted available memory\n");
+	a->Text = calloc(size + 1, sizeof(char));
+	require(NULL != a->Text, "Exhusted available memory\n");
+
+	int i = 0;
+	while(i <= size)
+	{
+		a->Text[i] = SCRATCH[i];
+		i = i + 1;
+	}
+	a->next = blob_list;
+	blob_list = a;
+	AddHash(a, SCRATCH);
+}
 
 struct Token* newToken(char* filename, int linenumber)
 {
@@ -133,36 +208,39 @@ struct Token* append_newline(struct Token* head, char* filename)
 {
 	linenumber = linenumber + 1;
 	if(NULL == head) return NULL;
-	if(NEWLINE == head->type)
+	if(NEWLINE == head->contents->type)
 	{/* Don't waste whitespace*/
 		return head;
 	}
 
 	struct Token* lf = newToken(filename, linenumber);
-	lf->type = NEWLINE;
+	lf->contents = newline_blob;
 	lf->next = head;
-	lf->Text = "\n";
-	lf->Expression = lf->Text;
 	return lf;
 }
 
 
 struct Token* store_atom(struct Token* head, char c, char* filename)
 {
-	char* store = calloc(max_string + 1, sizeof(char));
-	require(NULL != store, "Exhusted available memory\n");
+	ClearScratch();
 	int ch = c;
 	int i = 0;
 	do
 	{
-		store[i] = ch;
+		SCRATCH[i] = ch;
 		ch = fgetc(source_file);
 		i = i + 1;
 		require(i < max_string, "storing atom of size larger than max_string\n");
 		if(EOF == ch) break;
 	} while (!in_set(ch, "\t\n "));
 
-	head->Text = store;
+	head->contents = FindBlob();
+	if(NULL == head->contents)
+	{
+		NewBlob(i);
+		head->contents = blob_list;
+	}
+
 	if('\n' == ch)
 	{
 		return append_newline(head, filename);
@@ -170,16 +248,15 @@ struct Token* store_atom(struct Token* head, char c, char* filename)
 	return head;
 }
 
-char* store_string(char c, char* filename)
+struct blob* store_string(char c, char* filename)
 {
-	char* store = calloc(max_string + 1, sizeof(char));
-	require(NULL != store, "Exhusted available memory\n");
+	ClearScratch();
 
 	int ch = c;
 	int i = 0;
 	do
 	{
-		store[i] = ch;
+		SCRATCH[i] = ch;
 		i = i + 1;
 		if('\n' == ch) linenumber = linenumber + 1;
 		ch = fgetc(source_file);
@@ -189,13 +266,21 @@ char* store_string(char c, char* filename)
 		{
 			line_error(filename, linenumber);
 			file_print("String: ", stderr);
-			file_print(store, stderr);
+			file_print(SCRATCH, stderr);
 			file_print(" exceeds max string size\n", stderr);
 			exit(EXIT_FAILURE);
 		}
 	} while(ch != c);
 
-	return store;
+	struct blob* a = FindBlob();
+	if(NULL == a)
+	{
+		NewBlob(i);
+		a = blob_list;
+		a->type = STR;
+	}
+
+	return a;
 }
 
 struct Token* Tokenize_Line(struct Token* head, char* filename)
@@ -237,8 +322,7 @@ restart:
 		p->next = head;
 		if(in_set(c, "'\""))
 		{
-			p->Text = store_string(c, filename);
-			p->type = STR;
+			p->contents = store_string(c, filename);
 		}
 		else
 		{
@@ -251,68 +335,40 @@ done:
 	return head;
 }
 
-void setExpression(struct Token* p, char *c, char *Exp)
+void line_macro(struct Token* p)
 {
 	struct Token* i;
 	for(i = p; NULL != i; i = i->next)
 	{
-		/* Leave macros alone */
-		if(MACRO == i->type)
+		if(define_blob == i->contents)
 		{
-			if(match(i->Text, c))
+			require(NULL != i->next, "Macro name must exist\n");
+			require(NULL != i->next->next, "Macro value must exist\n");
+			if(PROCESSED == i->next->contents->type)
 			{
 				line_error(i->filename, i->linenumber);
 				file_print("Multiple definitions for macro ", stderr);
-				file_print(c, stderr);
+				file_print(i->next->contents->Text, stderr);
 				file_print("\n", stderr);
 				exit(EXIT_FAILURE);
 			}
-			continue;
-		}
-		else if(match(i->Text, c))
-		{ /* Only if there is an exact match replace */
-			i->Expression = Exp;
-		}
-	}
-}
 
-void identify_macros(struct Token* p)
-{
-	struct Token* i;
-	for(i = p; NULL != i; i = i->next)
-	{
-		if(match(i->Text, "DEFINE"))
-		{
-			i->type = MACRO;
-			require(NULL != i->next, "Macro name must exist\n");
-			i->Text = i->next->Text;
-			require(NULL != i->next->next, "Macro value must exist\n");
-			if(STR == i->next->next->type)
+			i->contents = newline_blob;
+
+			if (STR == i->next->next->contents->type)
 			{
-				i->Expression = i->next->next->Text + 1;
+				i->contents->Expression = i->next->next->contents->Text + 1;
 			}
 			else
 			{
-				i->Expression = i->next->next->Text;
+				i->next->contents->Expression = i->next->next->contents->Text;
 			}
 			i->next = i->next->next->next;
 		}
 	}
 }
 
-void line_macro(struct Token* p)
-{
-	struct Token* i;
-	for(i = p; NULL != i; i = i->next)
-	{
-		if(MACRO == i->type)
-		{
-			setExpression(i->next, i->Text, i->Expression);
-		}
-	}
-}
-
-void hexify_string(struct Token* p)
+void hexify_string(struct blob* p)
 {
 	char* table = "0123456789ABCDEF";
 	int i = string_length(p->Text);
@@ -381,9 +437,9 @@ void hexify_string(struct Token* p)
 	}
 }
 
-void process_string(struct Token* p)
+void process_string(struct blob* p)
 {
-	struct Token* i;
+	struct blob* i;
 	for(i = p; NULL != i; i = i->next)
 	{
 		if(STR == i->type)
@@ -421,12 +477,12 @@ char* pad_nulls(int size, char* nil)
 	return s;
 }
 
-void preserve_other(struct Token* p)
+void preserve_other(struct blob* p)
 {
-	struct Token* i;
+	struct blob* i;
 	for(i = p; NULL != i; i = i->next)
 	{
-		if((NULL == i->Expression) && !(i->type & MACRO))
+		if((NULL == i->Expression) && !(i->type & PROCESSED))
 		{
 			char c = i->Text[0];
 
@@ -438,14 +494,6 @@ void preserve_other(struct Token* p)
 			{
 				i->Expression = pad_nulls(numerate_string(i->Text + 1), i->Text);
 			}
-			else
-			{
-				line_error(i->filename, i->linenumber);
-				file_print("Received invalid other; ", stderr);
-				file_print(i->Text, stderr);
-				file_print("\n", stderr);
-				exit(EXIT_FAILURE);
-			}
 		}
 	}
 }
@@ -616,12 +664,12 @@ char* express_number(int value, char c)
 	return ch;
 }
 
-void eval_immediates(struct Token* p)
+void eval_immediates(struct blob* p)
 {
-	struct Token* i;
+	struct blob* i;
 	for(i = p; NULL != i; i = i->next)
 	{
-		if(MACRO == i->type) continue;
+		if(PROCESSED == i->type) continue;
 		else if(NEWLINE == i->type) continue;
 		else if('<' == i->Text[0]) continue;
 		else if(NULL == i->Expression)
@@ -629,10 +677,14 @@ void eval_immediates(struct Token* p)
 			int value;
 			if((X86 == Architecture) || (AMD64 == Architecture) || (ARMV7L == Architecture) || (AARM64 == Architecture))
 			{
-				value = numerate_string(i->Text + 1);
-				if(('0' == i->Text[1]) || (0 != value))
+				if(in_set(i->Text[0], "%~@!"))
 				{
-					i->Expression = express_number(value, i->Text[0]);
+					value = numerate_string(i->Text + 1);
+
+					if(('0' == i->Text[1]) || (0 != value))
+					{
+						i->Expression = express_number(value, i->Text[0]);
+					}
 				}
 			}
 			else if(KNIGHT == Architecture)
@@ -657,15 +709,23 @@ void print_hex(struct Token* p)
 	struct Token* i;
 	for(i = p; NULL != i; i = i->next)
 	{
-		if(NEWLINE == i->type)
+		if(NEWLINE == i->contents->type)
 		{
 			if(NULL == i->next) fputc('\n', destination_file);
-			else if((NEWLINE != i->next->type) && (MACRO != i->next->type)) fputc('\n', destination_file);
+			else if(NEWLINE != i->next->contents->type) fputc('\n', destination_file);
 		}
-		else if(i->type != MACRO)
+		else if(NULL != i->contents->Expression)
 		{
-			file_print(i->Expression, destination_file);
-			if(NEWLINE != i->next->type) fputc(' ', destination_file);
+			file_print(i->contents->Expression, destination_file);
+			if(NEWLINE != i->next->contents->type) fputc(' ', destination_file);
+		}
+		else
+		{
+			line_error(i->filename, i->linenumber);
+			file_print("Received invalid other; ", stderr);
+			file_print(i->contents->Text, stderr);
+			file_print("\n", stderr);
+			exit(EXIT_FAILURE);
 		}
 	}
 }
@@ -674,13 +734,31 @@ void print_hex(struct Token* p)
 int main(int argc, char **argv)
 {
 	BigEndian = TRUE;
-	struct Token* head = NULL;
 	Architecture = KNIGHT;
 	destination_file = stdout;
 	BigBitEndian = TRUE;
 	ByteMode = HEX;
 	char* filename;
 	char* arch;
+	blob_count = 2;
+	hash_table = calloc(65537, sizeof(struct blob*));
+
+	/* Create newline blob */
+	newline_blob = calloc(1, sizeof(struct blob));
+	newline_blob->Text = "\n";
+	newline_blob->Expression = "\n";
+	newline_blob->type = NEWLINE;
+	AddHash(newline_blob, "\n");
+
+	/* Start the blob list with DEFINE and newline */
+	blob_list = calloc(1, sizeof(struct blob));
+	blob_list->Text = "DEFINE";
+	define_blob = blob_list;
+	blob_list->next = newline_blob;
+	AddHash(define_blob, "DEFINE");
+
+	/* Initialize scratch */
+	SCRATCH = calloc(max_string + 1, sizeof(char));
 
 	int option_index = 1;
 	while(option_index <= argc)
@@ -743,7 +821,7 @@ int main(int argc, char **argv)
 				exit(EXIT_FAILURE);
 			}
 
-			head = Tokenize_Line(head, filename);
+			token_list = Tokenize_Line(token_list, filename);
 			option_index = option_index + 2;
 		}
 		else if(match(argv[option_index], "-o") || match(argv[option_index], "--output"))
@@ -776,19 +854,18 @@ int main(int argc, char **argv)
 		}
 	}
 
-	if(NULL == head)
+	if(NULL == token_list)
 	{
 		file_print("Either no input files were given or they were empty\n", stderr);
 		exit(EXIT_FAILURE);
 	}
 
-	head = reverse_list(head);
-	identify_macros(head);
-	line_macro(head);
-	process_string(head);
-	eval_immediates(head);
-	preserve_other(head);
-	print_hex(head);
+	token_list = reverse_list(token_list);
+	line_macro(token_list);
+	process_string(blob_list);
+	eval_immediates(blob_list);
+	preserve_other(blob_list);
+	print_hex(token_list);
 
 	return EXIT_SUCCESS;
 }
diff --git a/test/test2/proof.answer b/test/test2/proof.answer
index 7587f6c..60100f7 100644
--- a/test/test2/proof.answer
+++ b/test/test2/proof.answer
@@ -1 +1 @@
-4379770c34e718157f856d938f870ad8179b268e5454f9ff272aad4e43265149  test/test2/proof
+a9a48fdbff46b4d7e1596bae4bd44c23f554a285b404dc151b63a073b2efce62  test/test2/proof
-- 
2.20.1

